"Allows setting runtime defaults on arguments"
directive @default(
    "The runtime property to use for the default value"
    property : String!
) on ARGUMENT_DEFINITION

"Allows aliasing a result field by sourcing it to a different underlying field on the type being returned"
directive @fetch(
  from: String!
)
on FIELD_DEFINITION

"The unit of distance to use when considering a distance arg (for example, in location-related criteria)"
enum DistanceUnit {
  "Kilometers"
  KM

  "Miles"
  MI
}

"The languages currently supported"
enum Language {
  "German"
  DE

  "English"
  EN

  "Spanish"
  ES

  "French"
  FR

  "Italian"
  IT

  "Portuguese"
  PT

  "Portuguese (Brazil)"
  PT_BR

  "Russian"
  RU
}

"The populated-place types currently supported"
enum PopulatedPlaceType {
   "A level-2 administrative division (for example, a county)"
  ADM2

  "A city, town, or village"
  CITY
}

"What level of stale data is ok to pull"
enum IncludeDeletedFilterType {
  "All data, regardless of if/when marked deleted"
  ALL

  "Only data not marked deleted before yesterday"
  SINCE_YESTERDAY

  "Only data not marked deleted before last week"
  SINCE_LAST_WEEK

  "Only data not marked deleted"
  NONE
}

"How the results should be rendered"
input DisplayOptions {
  "Whether to display results using ASCII-only characters."
  asciiMode: Boolean = false

  "What language to display the results in."
  language: Language = EN
}

"Location GPS latitude/longitude coordinates"
input Location {
  "DD.DDDD from -90 to 90"
  latitude: Float

  "DD.DDDD from -180 to 180"
  longitude: Float
}

"The set of possible top-level queries"
type Query {
  "Look up a country"  
  country(
    id: ID!
    displayOptions: DisplayOptions
  ): Country

  "Find countries, filtering by optional criteria. If no criteria are set, you will get back all known countries."
  countries(
    currencyCode: String
    namePrefix: String

    first: Int
    after: String
    last: Int
    before: String

    displayOptions: DisplayOptions
  ): CountriesConnection

  "Find currencies, filtering by optional criteria. If no criteria are set, you will get back all known currencies."
  currencies(
    countryId: String

    first: Int
    after: String
    last: Int
    before: String
  ): CurrenciesConnection

  "Get the distance between any two places"
  distanceBetween(
    fromPlaceId: String
    toPlaceId: String
    distanceUnit: DistanceUnit = MI
  ): Float

  "Get all known locales"
  locales(
    first: Int
    after: String
    last: Int
    before: String
  ): LocalesConnection

  "Look up a populated place"
  populatedPlace(
    id: ID!
    displayOptions: DisplayOptions
  ): PopulatedPlace

  "Find populated places, filtering by optional criteria. If no criteria are set, you will get back all known places."
  populatedPlaces (
    location: Location
    radius: Float = 100
    distanceUnit: DistanceUnit = MI

    countryIds: [String]
    excludedCountryIds: [String]

    namePrefix: String
    minPopulation: Int @default(property:"defaults.minPopulation")
    maxPopulation: Int
    timeZoneIds: [String]
    types: [String]

    sort: String

    first: Int
    after: String
    last: Int
    before: String

    displayOptions: DisplayOptions

    includeDeleted: IncludeDeletedFilterType = NONE
  ): PopulatedPlacesConnection

  "Look up a time-zone"
  timeZone(id: ID!): TimeZone

  "Get all known time-zones"
  timeZones(
    first: Int
    after: String
    last: Int
    before: String
  ): TimeZonesConnection
}

type ConnectionPageInfo {
  startCursor: String
  endCursor: String
  hasNextPage: Boolean
  hasPreviousPage: Boolean
}

type Country {
  code: ID

  name: String
  wikiDataId: String

  currencyCodes: [String]
  flagImageUri: String

  numRegions: Int

  region(
    code: String
  ): CountryRegion

  regions(
    namePrefix: String

    first: Int
    after: String
    last: Int
    before: String
  ): CountryRegionsConnection
}

type CountryEdge {
  cursor: String
  node: Country
}

type CountriesConnection {
  totalCount: Int
  edges: [CountryEdge]
  pageInfo: ConnectionPageInfo
}

type CountryRegion {
  isoCode: ID

  fipsCode: String
  name: String
  wikiDataId: String

  capital: String

  country: Country

  numPopulatedPlaces: Int @fetch(from:"numCities")

  populatedPlaces (
    countryIds: [String]
    excludedCountryIds: [String]

    namePrefix: String
    minPopulation: Int @default(property:"defaults.minPopulation")
    maxPopulation: Int
    timeZoneIds: [String]
    types: [String]

    sort: String

    first: Int
    after: String
    last: Int
    before: String

    includeDeleted: IncludeDeletedFilterType = NONE
  ): RegionPopulatedPlacesConnection
}

type CountryRegionEdge {
  cursor: String
  node: CountryRegion
}

type CountryRegionsConnection {
  totalCount: Int
  edges: [CountryRegionEdge]
  pageInfo: ConnectionPageInfo
}

type Currency {
  countryCodes: [String]
  code: ID
  symbol: String
}

type CurrencyEdge {
  cursor: String
  node: Currency
}

type CurrenciesConnection {
  totalCount: Int
  edges: [CurrencyEdge]
  pageInfo: ConnectionPageInfo
}

type Locale {
  code: ID
  name: String
}

type LocaleEdge {
  cursor: String
  node: Locale
}

type LocalesConnection {
  totalCount: Int
  edges: [LocaleEdge]
  pageInfo: ConnectionPageInfo
}

type NearbyPopulatedPlacesConnection {
  totalCount: Int
  edges: [PopulatedPlaceEdge]
  pageInfo: ConnectionPageInfo
}

type PopulatedPlace {
  id: ID

  name: String
  placeType: PopulatedPlaceType @fetch(from:"type")
  wikiDataId: String

  elevationMeters: Int
  latitude: Float
  longitude: Float
  population: Int
  timezone: String

  country: Country
  region: CountryRegion

  distance(
    toPlaceId: String
    distanceUnit: DistanceUnit = MI
  ): Float

  nearbyPopulatedPlaces(
    radius: Float = 100
    distanceUnit: DistanceUnit = MI

    countryIds: [String]
    excludedCountryIds: [String]

    namePrefix: String
    minPopulation: Int @default(property:"defaults.minPopulation")
    maxPopulation: Int
    timeZoneIds: [String]
    types: [String]

    sort: String

    first: Int
    after: String
    last: Int
    before: String

    includeDeleted: IncludeDeletedFilterType = NONE
  ): NearbyPopulatedPlacesConnection

  deleted: Boolean
}

type PopulatedPlaceEdge {
  cursor: String
  node: PopulatedPlace
}

type PopulatedPlacesConnection {
  totalCount: Int
  edges: [PopulatedPlaceEdge]
  pageInfo: ConnectionPageInfo
}

type RegionPopulatedPlacesConnection {
  totalCount: Int
  edges: [PopulatedPlaceEdge]
  pageInfo: ConnectionPageInfo
}

type TimeZone {
  id: ID

  name: String
  rawUtcOffsetHours: Int

  dateTime: String
  time: String
}

type TimeZoneEdge {
  cursor: String
  node: TimeZone
}

type TimeZonesConnection {
  totalCount: Int
  edges: [TimeZoneEdge]
  pageInfo: ConnectionPageInfo
}