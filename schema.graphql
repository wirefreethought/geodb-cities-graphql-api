"Allows setting runtime defaults on arguments"
directive @default(
    "The runtime property to use for the default value"
    property : String!
) on ARGUMENT_DEFINITION

"Allows aliasing a result field by sourcing it to a different underlying field on the type being returned"
directive @fetch(
  from: String!
)
on FIELD_DEFINITION

"The unit of distance to use when considering a distance arg (for example, in location-related criteria)"
enum DistanceUnit {
  "Kilometers"
  KM

  "Miles"
  MI
}

"The languages currently supported"
enum Language {
  "German"
  DE

  "English"
  EN

  "Spanish"
  ES

  "French"
  FR

  "Italian"
  IT

  "Portuguese"
  PT

  "Portuguese (Brazil)"
  PT_BR

  "Russian"
  RU
}

"The populated-place types currently supported"
enum PopulatedPlaceType {
   "A level-2 administrative division (for example, a county)"
  ADM2

  "A city, town, or village"
  CITY
}

"What level of stale data is ok to pull"
enum IncludeDeletedFilterType {
  "All data, regardless of if/when marked deleted"
  ALL

  "Only data not marked deleted before yesterday"
  SINCE_YESTERDAY

  "Only data not marked deleted before last week"
  SINCE_LAST_WEEK

  "Only data not marked deleted"
  NONE
}

"How the results should be rendered"
input DisplayOptions {
  "Whether to display results using ASCII-only characters"
  asciiMode: Boolean = false

  "What language to display the results in"
  language: Language = EN
}

"Location GPS latitude/longitude coordinates"
input Location {
  "DD.DDDD from -90 to 90"
  latitude: Float

  "DD.DDDD from -180 to 180"
  longitude: Float
}

"The set of possible top-level queries"
type Query {
  "Look up a country"  
  country(
    id: ID!
    displayOptions: DisplayOptions
  ): Country

  "Find countries, filtering by optional criteria. If no criteria are set, you will get back all known countries."
  countries(
    currencyCode: String
    namePrefix: String

    first: Int
    after: String
    last: Int
    before: String

    displayOptions: DisplayOptions
  ): CountriesConnection

  "Find currencies, filtering by optional criteria. If no criteria are set, you will get back all known currencies."
  currencies(
    countryId: String

    first: Int
    after: String
    last: Int
    before: String
  ): CurrenciesConnection

  "Get the distance between any two places"
  distanceBetween(
    fromPlaceId: String
    toPlaceId: String
    distanceUnit: DistanceUnit = MI
  ): Float

  "Get all known locales"
  locales(
    first: Int
    after: String
    last: Int
    before: String
  ): LocalesConnection

  "Look up a populated place"
  populatedPlace(
    id: ID!
    displayOptions: DisplayOptions
  ): PopulatedPlace

  "Find populated places, filtering by optional criteria. If no criteria are set, you will get back all known places."
  populatedPlaces (
    location: Location
    radius: Float = 100
    distanceUnit: DistanceUnit = MI

    countryIds: [String]
    excludedCountryIds: [String]

    namePrefix: String
    minPopulation: Int @default(property:"defaults.minPopulation")
    maxPopulation: Int
    timeZoneIds: [String]
    types: [String]

    sort: String

    first: Int
    after: String
    last: Int
    before: String

    displayOptions: DisplayOptions

    includeDeleted: IncludeDeletedFilterType = NONE
  ): PopulatedPlacesConnection

  "Look up a time-zone"
  timeZone(id: ID!): TimeZone

  "Get all known time-zones"
  timeZones(
    first: Int
    after: String
    last: Int
    before: String
  ): TimeZonesConnection
}

"Info about the current connection page slice"
type ConnectionPageInfo {
  "The opaque id of the cursor representing the index of the first element in this page"
  startCursor: String

  "The opaque id of the cursor representing the index of the last element in this page"
  endCursor: String

  "Whether there are more pages in the results"
  hasNextPage: Boolean

  "Whether there are previous pages in the results"
  hasPreviousPage: Boolean
}

"A country"
type Country {
  "The ISO-3166 country code"
  code: String

  "The country WikiData id"
  wikiDataId: String

  "The country name (varies by requested language)"
  name: String

  "A list of supported ISO-4217 currency codes"
  currencyCodes: [String]

  "The country flag image"
  flagImageUri: String

  "The number of regions in this country"
  numRegions: Int

  "Look up a region in this country. This could be a state, province, district, or otherwise major political division."
  region(
    "An ISO-3166 or FIPS region code"
    code: String
  ): CountryRegion

  "Find regions in this country. These could be states, provinces, districts, or otherwise major political divisions."
  regions(
    "Only regions whose names start with this prefix. If language is set, the prefix will be matched on the name as it appears in that language."
    namePrefix: String

    "How many results to retrieve from the beginning (or after the 'after' cursor, if specified)"
    first: Int

    "The cursor id after which to get results"
    after: String

    "How many results to retrieve from the end (or before the 'before' cursor, if specified)"
    last: Int

    "The cursor id before which to get results"
    before: String
  ): CountryRegionsConnection
}

"When paging countries, wraps a country node together with the cursor referencing its position in the results"
type CountryEdge {
  cursor: String
  node: Country
}

"A pageable view into country results"
type CountriesConnection {
  "The total number of results"
  totalCount: Int

  "The edges in the current page of results"
  edges: [CountryEdge]

  "Info about the current page of results"
  pageInfo: ConnectionPageInfo
}

type CountryRegion {
  isoCode: ID

  fipsCode: String
  name: String
  wikiDataId: String

  capital: String

  country: Country

  numPopulatedPlaces: Int @fetch(from:"numCities")

  populatedPlaces (
    countryIds: [String]
    excludedCountryIds: [String]

    namePrefix: String
    minPopulation: Int @default(property:"defaults.minPopulation")
    maxPopulation: Int
    timeZoneIds: [String]
    types: [String]

    sort: String

    first: Int
    after: String
    last: Int
    before: String

    includeDeleted: IncludeDeletedFilterType = NONE
  ): RegionPopulatedPlacesConnection
}

type CountryRegionEdge {
  cursor: String
  node: CountryRegion
}

type CountryRegionsConnection {
  totalCount: Int
  edges: [CountryRegionEdge]
  pageInfo: ConnectionPageInfo
}

type Currency {
  countryCodes: [String]
  code: ID
  symbol: String
}

type CurrencyEdge {
  cursor: String
  node: Currency
}

type CurrenciesConnection {
  totalCount: Int
  edges: [CurrencyEdge]
  pageInfo: ConnectionPageInfo
}

type Locale {
  code: ID
  name: String
}

type LocaleEdge {
  cursor: String
  node: Locale
}

type LocalesConnection {
  totalCount: Int
  edges: [LocaleEdge]
  pageInfo: ConnectionPageInfo
}

type NearbyPopulatedPlacesConnection {
  totalCount: Int
  edges: [PopulatedPlaceEdge]
  pageInfo: ConnectionPageInfo
}

type PopulatedPlace {
  id: ID

  name: String
  placeType: PopulatedPlaceType @fetch(from:"type")
  wikiDataId: String

  elevationMeters: Int
  latitude: Float
  longitude: Float
  population: Int
  timezone: String

  country: Country
  region: CountryRegion

  distance(
    toPlaceId: String
    distanceUnit: DistanceUnit = MI
  ): Float

  nearbyPopulatedPlaces(
    radius: Float = 100
    distanceUnit: DistanceUnit = MI

    countryIds: [String]
    excludedCountryIds: [String]

    namePrefix: String
    minPopulation: Int @default(property:"defaults.minPopulation")
    maxPopulation: Int
    timeZoneIds: [String]
    types: [String]

    sort: String

    first: Int
    after: String
    last: Int
    before: String

    includeDeleted: IncludeDeletedFilterType = NONE
  ): NearbyPopulatedPlacesConnection

  deleted: Boolean
}

type PopulatedPlaceEdge {
  cursor: String
  node: PopulatedPlace
}

type PopulatedPlacesConnection {
  totalCount: Int
  edges: [PopulatedPlaceEdge]
  pageInfo: ConnectionPageInfo
}

type RegionPopulatedPlacesConnection {
  totalCount: Int
  edges: [PopulatedPlaceEdge]
  pageInfo: ConnectionPageInfo
}

type TimeZone {
  id: ID

  name: String
  rawUtcOffsetHours: Int

  dateTime: String
  time: String
}

type TimeZoneEdge {
  cursor: String
  node: TimeZone
}

type TimeZonesConnection {
  totalCount: Int
  edges: [TimeZoneEdge]
  pageInfo: ConnectionPageInfo
}